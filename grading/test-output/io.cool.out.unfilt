#name "./io.cool"
#1 '('
#1 '*'
#2 '*'
#2 LET
#2 OBJECTID he
#2 FI
#2 OF
#2 CLASS
#2 FI
#2 OBJECTID s
#2 OBJECTID predefined
#2 OBJECTID and
#2 OBJECTID has
#2 INT_CONST 4
#2 OBJECTID methods
#2 ':'
#3 '*'
#4 '*'
#4 ELSE
#4 OBJECTID out
LEXER BUG - UNMATCHED: _
#4 OBJECTID string
#4 '('
#4 OBJECTID s
#4 ':'
#4 TYPEID String
#4 ')'
#4 ':'
#4 TYPEID SELF_TYPE
#5 '*'
#5 ELSE
#5 OBJECTID out
LEXER BUG - UNMATCHED: _
#5 OBJECTID int
#5 '('
#5 IF
#5 ':'
#5 FI
#5 OBJECTID nt
#5 ')'
#5 ':'
#5 TYPEID SELF_TYPE
#6 '*'
#6 ELSE
#6 IN
LEXER BUG - UNMATCHED: _
#6 OBJECTID string
#6 '('
#6 ')'
#6 ':'
#6 TYPEID String
#7 '*'
#7 ELSE
#7 IN
LEXER BUG - UNMATCHED: _
#7 OBJECTID int
#7 '('
#7 ')'
#7 ':'
#7 FI
#7 OBJECTID nt
#8 '*'
#9 '*'
#9 ELSE
#9 THEN
#9 OBJECTID out
#9 OBJECTID operations
#9 OBJECTID print
#9 OBJECTID their
#9 OBJECTID argument
#9 OBJECTID to
#9 THEN
#9 OBJECTID terminal
#9 '.'
#9 TYPEID The
#10 '*'
#10 ELSE
#10 IN
LEXER BUG - UNMATCHED: _
#10 OBJECTID string
#10 OBJECTID method
#10 OBJECTID reads
#10 OBJECTID an
#10 OBJECTID entire
#10 OBJECTID line
#10 IF
#10 OBJECTID rom
#10 THEN
#10 OBJECTID terminal
#10 OBJECTID and
#10 OBJECTID returns
#10 OBJECTID a
#11 '*'
#11 CLASS
#11 OBJECTID tring
#11 IN
#11 OBJECTID ot
#11 OBJECTID containing
#11 THEN
#11 NEW
#11 OBJECTID line
#11 '.'
#11 THEN
#11 IN
LEXER BUG - UNMATCHED: _
#11 OBJECTID int
#11 OBJECTID method
#11 OBJECTID also
#11 OBJECTID reads
#12 '*'
#12 ELSE
#12 OBJECTID an
#12 OBJECTID entire
#12 OBJECTID line
#12 IF
#12 OBJECTID rom
#12 THEN
#12 OBJECTID terminal
#12 OBJECTID and
#12 OBJECTID returns
#12 THEN
#12 OBJECTID integer
#13 '*'
#13 ELSE
#13 OBJECTID corresponding
#13 OBJECTID to
#13 THEN
#13 OBJECTID first
#13 IN
#13 OBJECTID on
#13 OBJECTID blank
#13 OBJECTID word
#13 OBJECTID on
#13 THEN
#13 OBJECTID line
#13 '.'
#13 FI
#13 FI
#13 OBJECTID that
#14 '*'
#14 ELSE
#14 OBJECTID word
#14 FI
#14 OBJECTID s
#14 IN
#14 OBJECTID ot
#14 OBJECTID an
#14 FI
#14 OBJECTID nteger
#14 ','
#14 FI
#14 OBJECTID t
#14 OBJECTID returns
#14 INT_CONST 0
#14 '.'
#15 '*'
#16 '*'
#17 '*'
#17 FI
#17 TYPEID Because
#17 OBJECTID our
#17 OBJECTID language
#17 FI
#17 OBJECTID s
#17 OBJECTID object
#17 OBJECTID oriented
#17 ','
#17 OBJECTID we
#17 IN
#17 OBJECTID eed
#17 OBJECTID an
#17 OBJECTID object
#17 OF
#17 OBJECTID type
#18 '*'
#18 FI
#18 TYPEID IO
#18 FI
#18 OBJECTID n
#18 OBJECTID order
#18 OBJECTID to
#18 OBJECTID call
#18 OBJECTID any
#18 OF
#18 OBJECTID these
#18 OBJECTID methods
#18 '.'
#19 '*'
#20 '*'
#20 LET
#20 OBJECTID here
#20 OBJECTID are
#20 OBJECTID basically
#20 OBJECTID two
#20 OBJECTID ways
#20 OF
#20 OBJECTID getting
#20 OBJECTID access
#20 OBJECTID to
#20 FI
#20 OF
#20 IN
#20 OBJECTID a
#20 CLASS
#20 TYPEID C
#20 '.'
#21 '*'
#22 '*'
#22 LET
#22 INT_CONST 1
#22 ')'
#22 TYPEID Define
#22 TYPEID C
#22 OBJECTID to
#22 FI
#22 OBJECTID nherit
#22 IF
#22 OBJECTID rom
#22 FI
#22 TYPEID O
#22 '.'
#22 TYPEID This
#22 OBJECTID way
#22 THEN
#22 TYPEID IO
#22 OBJECTID methods
#22 OBJECTID become
#23 '*'
#23 CLASS
#23 OBJECTID methods
#23 OF
#23 TYPEID C
#23 ','
#23 OBJECTID and
#23 OBJECTID they
#23 OBJECTID can
#23 OBJECTID be
#23 OBJECTID called
#23 OBJECTID using
#23 THEN
#23 OBJECTID abbreviated
#24 '*'
#24 CLASS
#24 OBJECTID dispatch
#24 ','
#24 FI
#24 '.'
#24 OBJECTID e
#24 '.'
#25 '*'
#26 '*'
#26 CLASS
#26 CLASS
#26 TYPEID C
#26 FI
#26 OBJECTID nherits
#26 FI
#26 OF
#26 OBJECTID is
#27 '*'
#27 INHERITS
#27 FI
#27 '.'
#27 '.'
#27 '.'
#28 '*'
#28 INHERITS
#28 FI
#28 OBJECTID out
LEXER BUG - UNMATCHED: _
#28 OBJECTID string
#28 '('
#28 STR_CONST "Hello world\\n"
#28 ')'
#29 '*'
#29 INHERITS
#29 FI
#29 '.'
#29 '.'
#29 '.'
#30 '*'
#30 CLASS
#30 OBJECTID end
#30 ';'
#31 '*'
#32 '*'
#32 LET
#32 INT_CONST 2
#32 ')'
#32 FI
#32 FI
#32 OBJECTID your
#32 CLASS
#32 TYPEID C
#32 OBJECTID does
#32 IN
#32 OBJECTID ot
#32 OBJECTID directly
#32 OBJECTID or
#32 FI
#32 OBJECTID ndirectly
#32 FI
#32 OBJECTID nherit
#32 IF
#32 OBJECTID rom
#33 '*'
#33 CLASS
#33 FI
#33 TYPEID O
#33 ','
#33 THEN
#33 OBJECTID best
#33 OBJECTID way
#33 OBJECTID to
#33 OBJECTID access
#33 FI
#33 OF
#33 OBJECTID is
#33 OBJECTID through
#33 OBJECTID an
#33 FI
#33 OBJECTID nitialized
#34 '*'
#34 CLASS
#34 OBJECTID attribute
#34 OF
#34 OBJECTID type
#34 FI
#34 TYPEID O
#34 '.'
#35 '*'
#36 '*'
#36 CLASS
#36 CLASS
#36 TYPEID C
#36 FI
#36 OBJECTID nherits
#36 IF
#36 OBJECTID oo
#36 FI
#36 OBJECTID s
#37 '*'
#37 INHERITS
#37 FI
#37 OF
#37 ':'
#37 FI
#37 OF
#37 ASSIGN
#37 IN
#37 OBJECTID ew
#37 FI
#37 TYPEID O
#37 ';'
#38 '*'
#38 INHERITS
#38 '.'
#38 '.'
#38 '.'
#39 '*'
#39 INHERITS
#39 CLASS
#39 OBJECTID io
#39 '.'
#39 OBJECTID out
LEXER BUG - UNMATCHED: _
#39 OBJECTID string
#39 '('
#39 STR_CONST "Hello world\\n"
#39 ')'
#39 ';'
#40 '*'
#40 INHERITS
#40 '.'
#40 '.'
#40 '.'
#41 '*'
#41 CLASS
#41 OBJECTID end
#41 ';'
#42 '*'
#43 '*'
#43 FI
#43 TYPEID Approach
#43 INT_CONST 1
#43 ')'
#43 FI
#43 OBJECTID s
#43 OBJECTID most
#43 OBJECTID often
#43 OBJECTID used
#43 ','
#43 FI
#43 OBJECTID n
#43 OBJECTID particular
#43 OBJECTID when
#43 OBJECTID you
#43 IN
#43 OBJECTID eed
#43 FI
#43 TYPEID O
#44 '*'
#44 FI
#44 OBJECTID functions
#44 FI
#44 OBJECTID n
#44 THEN
#44 TYPEID Main
#44 CLASS
#44 '.'
#45 '*'
#46 '*'
#46 ')'
#49 CLASS
#49 TYPEID A
#49 '{'
#51 LET
#51 '-'
#51 '-'
#51 LET
LEXER BUG - UNMATCHED: '
#51 OBJECTID s
#51 OBJECTID assume
#51 OBJECTID that
#51 OBJECTID we
#51 OBJECTID don
LEXER BUG - UNMATCHED: '
#51 OBJECTID t
#51 OBJECTID want
#51 TYPEID A
#51 OBJECTID to
#51 IN
#51 OBJECTID ot
#51 FI
#51 OBJECTID nherit
#51 IF
#51 OBJECTID rom
#51 FI
#51 TYPEID O
#51 '.'
#53 LET
#53 OBJECTID io
#53 ':'
#53 FI
#53 OF
#53 ASSIGN
#53 IN
#53 OBJECTID ew
#53 FI
#53 TYPEID O
#53 ';'
#55 LET
#55 OBJECTID out
LEXER BUG - UNMATCHED: _
#55 OBJECTID a
#55 '('
#55 ')'
#55 ':'
#55 TYPEID Object
#55 '{'
#55 FI
#55 OBJECTID o
#55 '.'
#55 OBJECTID out
LEXER BUG - UNMATCHED: _
#55 OBJECTID string
#55 '('
#55 STR_CONST "A: Hello world\\n"
#55 ')'
#55 '}'
#55 ';'
#57 '}'
#57 ';'
#60 CLASS
#60 TYPEID B
#60 FI
#60 OBJECTID nherits
#60 TYPEID A
#60 '{'
#62 LET
#62 '-'
#62 '-'
#62 TYPEID B
#62 OBJECTID does
#62 IN
#62 OBJECTID ot
#62 OBJECTID have
#62 OBJECTID to
#62 OBJECTID an
#62 OBJECTID extra
#62 OBJECTID attribute
#62 ','
#62 OBJECTID since
#62 FI
#62 OBJECTID t
#62 FI
#62 OBJECTID nherits
#62 FI
#62 OF
#62 OBJECTID from
#62 TYPEID A
#62 '.'
#64 LET
#64 OBJECTID out
LEXER BUG - UNMATCHED: _
#64 OBJECTID b
#64 '('
#64 ')'
#64 ':'
#64 TYPEID Object
#64 '{'
#64 FI
#64 OBJECTID o
#64 '.'
#64 OBJECTID out
LEXER BUG - UNMATCHED: _
#64 OBJECTID string
#64 '('
#64 STR_CONST "B: Hello world\\n"
#64 ')'
#64 '}'
#64 ';'
#66 '}'
#66 ';'
#69 CLASS
#69 TYPEID C
#69 FI
#69 OBJECTID nherits
#69 FI
#69 OF
#69 '{'
#71 LET
#71 '-'
#71 '-'
#71 IN
#71 OBJECTID ow
#71 THEN
#71 TYPEID IO
#71 OBJECTID methods
#71 OBJECTID are
#71 OBJECTID part
#71 OF
#71 TYPEID C
#71 '.'
#73 LET
#73 OBJECTID out
LEXER BUG - UNMATCHED: _
#73 OBJECTID c
#73 '('
#73 ')'
#73 ':'
#73 TYPEID Object
#73 '{'
#73 OBJECTID out
LEXER BUG - UNMATCHED: _
#73 OBJECTID string
#73 '('
#73 STR_CONST "C: Hello world\\n"
#73 ')'
#73 '}'
#73 ';'
#75 LET
#75 '-'
#75 '-'
#75 IN
#75 OBJECTID ote
#75 OBJECTID that
#75 OBJECTID out
LEXER BUG - UNMATCHED: _
#75 OBJECTID string
#75 '('
#75 '.'
#75 '.'
#75 '.'
#75 ')'
#75 FI
#75 OBJECTID s
#75 OBJECTID just
#75 OBJECTID a
#75 OBJECTID shorthand
#75 IF
#75 OBJECTID or
#75 OBJECTID self
#75 '.'
#75 OBJECTID out
LEXER BUG - UNMATCHED: _
#75 OBJECTID string
#75 '('
#75 '.'
#75 '.'
#75 '.'
#75 ')'
#77 '}'
#77 ';'
#80 CLASS
#80 TYPEID D
#80 FI
#80 OBJECTID nherits
#80 TYPEID C
#80 '{'
#82 LET
#82 '-'
#82 '-'
#82 FI
#82 OBJECTID nherits
#82 FI
#82 OF
#82 OBJECTID methods
#82 IF
#82 OBJECTID rom
#82 TYPEID C
#82 '.'
#84 LET
#84 OBJECTID out
LEXER BUG - UNMATCHED: _
#84 OBJECTID d
#84 '('
#84 ')'
#84 ':'
#84 TYPEID Object
#84 '{'
#84 OBJECTID out
LEXER BUG - UNMATCHED: _
#84 OBJECTID string
#84 '('
#84 STR_CONST "D: Hello world\\n"
#84 ')'
#84 '}'
#84 ';'
#86 '}'
#86 ';'
#89 CLASS
#89 TYPEID Main
#89 FI
#89 OBJECTID nherits
#89 FI
#89 OF
#89 '{'
#91 LET
#91 '-'
#91 '-'
#91 TYPEID Same
#91 CASE
#91 CASE
#91 CLASS
#91 TYPEID C
#91 '.'
#93 LET
#93 OBJECTID main
#93 '('
#93 ')'
#93 ':'
#93 TYPEID Object
#93 '{'
#94 CLASS
#94 '{'
#95 '('
#95 NEW
#95 TYPEID A
#95 ')'
#95 '.'
#95 OBJECTID out
LEXER BUG - UNMATCHED: _
#95 OBJECTID a
#95 '('
#95 ')'
#95 ';'
#96 '('
#96 NEW
#96 TYPEID B
#96 ')'
#96 '.'
#96 OBJECTID out
LEXER BUG - UNMATCHED: _
#96 OBJECTID b
#96 '('
#96 ')'
#96 ';'
#97 '('
#97 NEW
#97 TYPEID C
#97 ')'
#97 '.'
#97 OBJECTID out
LEXER BUG - UNMATCHED: _
#97 OBJECTID c
#97 '('
#97 ')'
#97 ';'
#98 '('
#98 NEW
#98 TYPEID D
#98 ')'
#98 '.'
#98 OBJECTID out
LEXER BUG - UNMATCHED: _
#98 OBJECTID d
#98 '('
#98 ')'
#98 ';'
#99 OBJECTID out
LEXER BUG - UNMATCHED: _
#99 OBJECTID string
#99 '('
LEXER BUG - UNMATCHED: "
#99 TYPEID Done
#99 '.'
LEXER BUG - UNMATCHED: \
#99 OBJECTID n
LEXER BUG - UNMATCHED: "
#99 ')'
#99 ';'
#100 CLASS
#100 '}'
#101 LET
#101 '}'
#101 ';'
#103 '}'
#103 ';'
